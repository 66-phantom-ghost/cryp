<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ShadowFX | Pro Messenger</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;700&display=swap');
        :root { --primary: #ef4444; --bg: #000000; }
        body { 
            background-color: var(--bg); color: #e4e4e7; font-family: 'Inter', sans-serif; 
            height: 100dvh; margin: 0; overflow: hidden; -webkit-tap-highlight-color: transparent;
        }
        .ios-blur { background: rgba(10, 10, 10, 0.8); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); }
        .bubble { max-width: 75%; padding: 10px 14px; border-radius: 18px; font-size: 14px; position: relative; transition: transform 0.2s; display: flex; flex-direction: column; }
        .bubble-me { background: var(--primary); color: white; align-self: flex-end; border-bottom-right-radius: 4px; }
        .bubble-peer { background: #1c1c1e; align-self: flex-start; border-bottom-left-radius: 4px; }
        .no-select { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        .offline-notice { position: fixed; top: 0; left: 0; right: 0; z-index: 9999; background: #ef4444; color: white; font-size: 10px; font-weight: 800; text-align: center; padding: 6px; text-transform: uppercase; letter-spacing: 0.1em; transition: all 0.3s ease; }
        .animate-slide-up { animation: slideUp 0.3s ease-out; }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body class="no-select">

    <div id="offline-banner" class="offline-notice hidden">Relay-Verbindung unterbrochen – Reconnect...</div>

    <!-- Onboarding / Login -->
    <div id="onboarding" class="fixed inset-0 bg-black z-[6000] p-10 flex flex-col justify-center items-center text-center">
        <div class="w-20 h-20 bg-red-500/10 rounded-[2rem] flex items-center justify-center mb-6 border border-red-500/20">
            <i data-lucide="shield-check" class="w-10 h-10 text-red-500"></i>
        </div>
        <h1 class="text-2xl font-bold mb-8 uppercase tracking-tighter text-white">ShadowFX Pro</h1>
        <div class="w-full max-w-xs space-y-3">
            <input type="text" id="user-display-input" placeholder="PSEUDONYM" class="w-full bg-zinc-900 p-4 rounded-xl border border-zinc-800 text-center text-white font-bold outline-none text-xs uppercase">
            <button onclick="setupApp()" class="w-full bg-red-500 p-4 rounded-xl font-bold text-white uppercase text-xs active:scale-95 transition-all">Einsteigen</button>
        </div>
    </div>

    <!-- Main UI -->
    <div id="app-ui" class="flex flex-col h-full hidden">
        <header class="ios-blur pt-12 pb-4 px-6 border-b border-zinc-900 flex justify-between items-center z-50">
            <div class="flex items-center gap-3">
                <button id="back-btn" onclick="nav('chats')" class="hidden w-8 h-8 flex items-center justify-center text-white"><i data-lucide="arrow-left" class="w-5 h-5"></i></button>
                <h1 id="view-title" class="font-bold text-xl uppercase tracking-tighter text-white">Chats</h1>
            </div>
            <div id="connection-indicator" class="w-2 h-2 rounded-full bg-zinc-700 transition-colors duration-500"></div>
        </header>
        <main id="main-content" class="flex-1 overflow-y-auto p-4 flex flex-col gap-2"></main>
        
        <!-- Tab Bar -->
        <nav id="bottom-nav" class="ios-blur pb-8 pt-2 px-10 border-t border-zinc-900 flex justify-around items-center z-50">
            <button onclick="nav('chats')" id="nav-chats" class="p-2 text-white"><i data-lucide="message-circle"></i></button>
            <button onclick="nav('invite')" id="nav-invite" class="p-2 text-zinc-600"><i data-lucide="share-2"></i></button>
            <button onclick="fullReset()" class="p-2 text-zinc-600"><i data-lucide="trash-2"></i></button>
        </nav>
    </div>

    <!-- Join Modal -->
    <div id="invite-modal" class="fixed inset-0 z-[7000] bg-black/95 p-8 flex flex-col justify-center items-center hidden">
        <h2 class="text-xl font-bold mb-4 uppercase text-white">Tunnel beitreten</h2>
        <textarea id="invite-input" placeholder="SFX#..." class="w-full h-32 bg-zinc-900 border border-zinc-800 p-4 rounded-xl font-mono text-white text-[10px] mb-4 outline-none resize-none"></textarea>
        <button onclick="processInviteCode()" class="w-full bg-white text-black p-4 rounded-xl font-bold uppercase text-xs">Aktivieren</button>
        <button onclick="$('invite-modal').classList.add('hidden')" class="mt-6 text-zinc-600 text-[10px] uppercase font-bold">Abbrechen</button>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        
        // Nutzt die Adresse aus deinem Go/React-Setup
        const RELAY_HOST = "unwintry-strapping-winford.ngrok-free.dev"; 
        
        let socket, isConnected = false;
        let state = { profiles: [], activeProfileId: null, view: 'chats', activeChatId: null, generatedCode: null };

        // Kryptographie Helfer
        async function generateKeyPair() { return await crypto.subtle.generateKey({ name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" }, true, ["encrypt", "decrypt"]); }
        async function exportKey(key) { const format = key.type === "public" ? "spki" : "pkcs8"; const exported = await crypto.subtle.exportKey(format, key); return btoa(String.fromCharCode(...new Uint8Array(exported))); }
        async function importPublicKey(pem) { return await crypto.subtle.importKey("spki", new Uint8Array(atob(pem).split("").map(c => c.charCodeAt(0))).buffer, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]); }
        async function importPrivateKey(pem) { return await crypto.subtle.importKey("pkcs8", new Uint8Array(atob(pem).split("").map(c => c.charCodeAt(0))).buffer, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["decrypt"]); }
        async function encryptRSA(pubKey, text) { const data = new TextEncoder().encode(text); const encrypted = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, pubKey, data); return btoa(String.fromCharCode(...new Uint8Array(encrypted))); }
        async function decryptRSA(privKey, b64) { const decrypted = await crypto.subtle.decrypt({ name: "RSA-OAEP" }, privKey, new Uint8Array(atob(b64).split("").map(c => c.charCodeAt(0))).buffer); return new TextDecoder().decode(decrypted); }

        function getActiveProfile() { return state.profiles.find(p => p.id === state.activeProfileId); }

        function initSocket() {
            if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) return;
            
            console.log("Versuche Verbindung zu:", RELAY_HOST);
            socket = new WebSocket(`wss://${RELAY_HOST}`);
            
            socket.onopen = () => {
                isConnected = true;
                $('connection-indicator').className = 'w-2 h-2 rounded-full bg-emerald-500';
                $('offline-banner').classList.add('hidden');
                const p = getActiveProfile();
                if (p) {
                    socket.send(JSON.stringify({ type: 'OPEN_ANON_QUEUE', queueId: p.queueId }));
                    console.log("Queue geöffnet:", p.queueId);
                }
            };
            
            socket.onmessage = async (e) => {
                try {
                    const data = JSON.parse(e.data);
                    if (data.type === 'RELAY_IN') handleRelay(data.payload);
                } catch(err) { console.error("Message parse error", err); }
            };
            
            socket.onclose = () => { 
                isConnected = false; 
                $('connection-indicator').className = 'w-2 h-2 rounded-full bg-red-500'; 
                if (getActiveProfile()) {
                    $('offline-banner').classList.remove('hidden');
                }
                setTimeout(initSocket, 5000); 
            };

            socket.onerror = (err) => {
                console.error("WebSocket Error:", err);
            };
        }

        async function handleRelay(payload) {
            const p = getActiveProfile();
            if (!p) return;
            try {
                const privKey = await importPrivateKey(p.privateKeyPem);
                const decryptedStr = await decryptRSA(privKey, payload.text);
                const msgObj = JSON.parse(decryptedStr);

                if (msgObj.type === 'ACCEPT_HANDSHAKE') {
                    if (!p.contacts.find(c => c.pubKey === payload.from)) {
                        p.contacts.push({ id: 'C-'+Date.now(), name: msgObj.name, pubKey: payload.from, queueId: msgObj.q });
                        save(); render();
                    }
                    return;
                }

                let contact = p.contacts.find(c => c.pubKey === payload.from);
                if (contact) {
                    if (!p.messages[contact.id]) p.messages[contact.id] = [];
                    p.messages[contact.id].push({ type: 'peer', text: msgObj.text, time: Date.now() });
                } else {
                    if (!p.pendingRequests.find(r => r.pubKey === payload.from)) {
                        p.pendingRequests.push({ pubKey: payload.from, name: msgObj.name, queueId: msgObj.q, firstMsg: msgObj.text || "Anfrage erhalten" });
                    }
                }
                save(); render();
            } catch(e) { console.error("Entschlüsselung fehlgeschlagen", e); }
        }

        function setupApp() {
            const name = $('user-display-input').value.trim();
            if (!name) return;
            generateKeyPair().then(async keys => {
                const p = {
                    id: 'P-' + Date.now(), name,
                    queueId: 'Q-' + Math.random().toString(36).substring(2, 12).toUpperCase(),
                    pubKey: await exportKey(keys.publicKey),
                    privateKeyPem: await exportKey(keys.privateKey),
                    contacts: [], pendingRequests: [], messages: {}
                };
                state.profiles = [p]; state.activeProfileId = p.id;
                save(); bootstrap();
            });
        }

        function bootstrap() {
            const p = getActiveProfile();
            if(!p) return;
            $('onboarding').classList.add('hidden');
            $('app-ui').classList.remove('hidden');
            initSocket(); render();
        }

        function nav(v) { 
            state.view = v; 
            if (v !== 'invite') state.generatedCode = null; 
            $('nav-chats').className = v === 'chats' ? 'p-2 text-white' : 'p-2 text-zinc-600';
            $('nav-invite').className = v === 'invite' ? 'p-2 text-white' : 'p-2 text-zinc-600';
            render(); 
        }

        function generateInvite() {
            const p = getActiveProfile();
            const shareData = btoa(JSON.stringify({ n: p.name, k: p.pubKey, q: p.queueId }));
            state.generatedCode = `SFX#${shareData}`;
            render();
        }

        async function processInviteCode() {
            const code = $('invite-input').value.trim();
            if (!code.startsWith('SFX#')) return;
            try {
                const data = JSON.parse(atob(code.split('#')[1]));
                const p = getActiveProfile();
                const payload = { name: p.name, q: p.queueId, text: "Tunnel-Anfrage" };
                const peerKey = await importPublicKey(data.k);
                const enc = await encryptRSA(peerKey, JSON.stringify(payload));
                socket.send(JSON.stringify({ type: 'CHAT_MSG', to: data.q, payload: { from: p.pubKey, text: enc } }));
                $('invite-modal').classList.add('hidden');
                $('invite-input').value = '';
                showBanner("Anfrage gesendet!");
            } catch(e) { showBanner("Fehler beim Code", "#ef4444"); }
        }

        async function acceptReq(index) {
            const p = getActiveProfile();
            const req = p.pendingRequests[index];
            const cid = 'C-' + Date.now();
            
            p.contacts.push({ id: cid, name: req.name, pubKey: req.pubKey, queueId: req.queueId });
            p.messages[cid] = [{ type: 'peer', text: req.firstMsg, time: Date.now() }];
            p.pendingRequests.splice(index, 1);

            const peerKey = await importPublicKey(req.pubKey);
            const handshake = { type: 'ACCEPT_HANDSHAKE', name: p.name, q: p.queueId };
            const enc = await encryptRSA(peerKey, JSON.stringify(handshake));
            socket.send(JSON.stringify({ type: 'CHAT_MSG', to: req.queueId, payload: { from: p.pubKey, text: enc } }));

            save(); render();
        }

        function render() {
            const p = getActiveProfile();
            const content = $('main-content');
            if(!p) return;
            
            $('back-btn').classList.add('hidden');
            $('bottom-nav').classList.remove('hidden');
            $('view-title').innerText = state.view === 'chats' ? 'Chats' : (state.view === 'invite' ? 'Einladen' : 'Chat');
            
            if (state.view === 'chats') {
                content.innerHTML = `<button onclick="$('invite-modal').classList.remove('hidden')" class="w-full bg-zinc-900 p-4 rounded-xl mb-4 text-[10px] font-bold text-red-500 uppercase border border-zinc-800">Key einlösen</button>`;
                p.pendingRequests.forEach((r, i) => {
                    content.innerHTML += `<div class="p-4 bg-red-500/10 border border-red-500/30 rounded-xl mb-2 flex justify-between items-center"><span class="text-xs font-bold text-white">${r.name} will chatten</span><button onclick="acceptReq(${i})" class="bg-white text-black px-3 py-1 rounded-lg text-[10px] font-bold">ANNEHMEN</button></div>`;
                });
                p.contacts.forEach(c => {
                    content.innerHTML += `<div onclick="state.activeChatId='${c.id}';state.view='chat-detail';render()" class="p-4 bg-zinc-900 rounded-xl mb-2 flex justify-between items-center active:scale-[0.98] transition-transform"><span class="font-bold text-sm text-white">${c.name}</span><i data-lucide="chevron-right" class="w-4 h-4 opacity-20"></i></div>`;
                });
            } else if (state.view === 'invite') {
                if (!state.generatedCode) {
                    content.innerHTML = `
                        <div class="flex-1 flex flex-col items-center justify-center p-6 text-center h-full">
                            <div class="w-16 h-16 bg-red-500/5 border border-red-500/20 rounded-3xl flex items-center justify-center mb-6">
                                <i data-lucide="key" class="text-red-500 w-8 h-8"></i>
                            </div>
                            <h2 class="text-white font-bold mb-2 uppercase text-sm">Tunnel-Key</h2>
                            <p class="text-[10px] text-zinc-500 mb-8 uppercase leading-relaxed tracking-widest">
                                Generiere einen einmaligen Tunnel-Key,<br>um eine Verbindung zu starten.
                            </p>
                            <button onclick="generateInvite()" class="w-full bg-red-500 text-white p-4 rounded-xl font-bold text-xs uppercase shadow-lg shadow-red-500/20">Tunnel-Key generieren</button>
                        </div>
                    `;
                } else {
                    content.innerHTML = `
                        <div class="p-6 text-center animate-slide-up">
                            <p class="text-[10px] text-zinc-500 mb-4 uppercase tracking-widest text-zinc-400">Dein RSA Tunnel Key</p>
                            <div class="bg-zinc-900 p-4 rounded-xl font-mono text-[9px] break-all mb-4 text-zinc-300 border border-zinc-800 select-all leading-relaxed">
                                ${state.generatedCode}
                            </div>
                            <button onclick="copy('${state.generatedCode}')" class="w-full bg-white text-black p-4 rounded-xl font-bold text-xs uppercase mb-4 active:bg-zinc-200">Key Kopieren</button>
                            <button onclick="state.generatedCode=null;render()" class="text-zinc-600 text-[10px] font-bold uppercase hover:text-zinc-400">Verwerfen</button>
                        </div>
                    `;
                }
            } else if (state.view === 'chat-detail') {
                $('back-btn').classList.remove('hidden');
                $('bottom-nav').classList.add('hidden');
                const c = p.contacts.find(c => c.id === state.activeChatId);
                const msgs = p.messages[c.id] || [];
                $('view-title').innerText = c.name;
                content.innerHTML = `<div class="flex-1 overflow-y-auto flex flex-col gap-2 pb-20" id="chat-box"></div><div class="fixed bottom-4 left-4 right-4 flex gap-2"><input id="msg-in" class="flex-1 bg-zinc-900 p-4 rounded-xl outline-none text-white border border-zinc-800" placeholder="Nachricht..."><button onclick="sendMessage()" class="bg-red-500 px-6 rounded-xl font-bold text-white"><i data-lucide="send" class="w-5 h-5"></i></button></div>`;
                const box = $('chat-box');
                msgs.forEach(m => {
                    box.innerHTML += `<div class="bubble ${m.type==='me'?'bubble-me':'bubble-peer'} animate-slide-up">${m.text}</div>`;
                });
                box.scrollTop = box.scrollHeight;
            }
            lucide.createIcons();
        }

        async function sendMessage() {
            const inp = $('msg-in');
            const text = inp.value.trim();
            if(!text || !isConnected) return;
            const p = getActiveProfile();
            const contact = p.contacts.find(c => c.id === state.activeChatId);
            p.messages[contact.id].push({ type: 'me', text, time: Date.now() });
            
            const peerKey = await importPublicKey(contact.pubKey);
            const enc = await encryptRSA(peerKey, JSON.stringify({ text }));
            socket.send(JSON.stringify({ type: 'CHAT_MSG', to: contact.queueId, payload: { from: p.pubKey, text: enc } }));
            
            inp.value = ''; save(); render();
        }

        function showBanner(t, c="#10b981") { 
            const b = $('offline-banner');
            b.innerText = t; b.style.backgroundColor = c; 
            b.classList.remove('hidden'); 
            setTimeout(() => b.classList.add('hidden'), 2000); 
        }

        function save() { localStorage.setItem('sfx_data', JSON.stringify(state)); }

        function copy(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed"; textArea.style.opacity = "0";
            document.body.appendChild(textArea);
            textArea.select();
            const success = document.execCommand('copy');
            document.body.removeChild(textArea);
            if (success) showBanner("Kopiert!");
        }

        function fullReset() { if(confirm("ALLES LÖSCHEN?")) { localStorage.clear(); location.reload(); } }
        
        window.onload = () => {
            const saved = localStorage.getItem('sfx_data');
            if(saved) { state = JSON.parse(saved); bootstrap(); }
        };
    </script>
</body>
</html>
