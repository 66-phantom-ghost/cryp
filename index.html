<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AnimeCyber Encryptor</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
/* Grunddesign */
body {
  margin: 0;
  font-family: 'Fira Code', monospace;
  background: radial-gradient(circle at top, #0b0c1e, #11121f 70%);
  color: #ffffff;
  display: flex;
  justify-content: center;
  padding: 2rem;
  min-height: 100vh;
  overflow: hidden;
}

/* Animierter Hintergrund */
@keyframes moveGrid {
  0% {background-position: 0 0;}
  100% {background-position: 1000px 1000px;}
}
body::before {
  content: "";
  position: fixed;
  top:0; left:0;
  width:100%; height:100%;
  background-image: repeating-linear-gradient(45deg, #ff4dff10 0, #ff4dff10 1px, transparent 1px, transparent 20px),
                    repeating-linear-gradient(-45deg, #4dffff10 0, #4dffff10 1px, transparent 1px, transparent 20px);
  background-size: 50px 50px;
  z-index:0;
  animation: moveGrid 30s linear infinite;
}

/* Container */
.container {
  position: relative;
  z-index:1;
  max-width: 650px;
  width: 100%;
  background: rgba(15,15,30,0.9);
  border-radius: 20px;
  padding: 2rem;
  box-shadow: 0 0 40px #ff4dff50, 0 0 40px #4dffff50 inset;
}

/* Ãœberschrift */
h1 {
  text-align: center;
  font-size: 2rem;
  margin-bottom: 1.5rem;
  color: #ff77ff;
  text-shadow: 0 0 8px #ff77ff80;
}

/* Inputs & Textareas */
input, textarea {
  width: 100%;
  background: rgba(20,20,40,0.8);
  color: #ffccff;
  border: 1px solid #ff77ff80;
  border-radius: 12px;
  padding: 0.8rem;
  margin-bottom: 1rem;
  transition: all 0.2s;
}
input:focus, textarea:focus {
  border-color: #ffccff;
  box-shadow: 0 0 12px #ff77ff50;
  outline: none;
}

/* Buttons */
button {
  width: 48%;
  padding: 0.8rem;
  background: linear-gradient(135deg, #ff77ff, #77ffff);
  color: #0b0c1e;
  font-weight: bold;
  border-radius: 12px;
  margin-right: 2%;
  transition: 0.2s;
  cursor: pointer;
  box-shadow: 0 0 10px #ff77ff50, 0 0 10px #77ffff50 inset;
}
button:hover {
  transform: scale(1.05);
  box-shadow: 0 0 20px #ff77ff80, 0 0 20px #77ffff80 inset;
}

/* Output Box */
.output {
  background: rgba(20,20,40,0.85);
  color: #ccffdd;
  padding: 1rem;
  border-radius: 12px;
  border: 1px dashed #77ffff80;
  white-space: pre-wrap;
  word-break: break-word;
  margin-top: 1rem;
  position: relative;
  transition: all 0.2s;
}
.output:hover {
  box-shadow: 0 0 15px #77ffff50, 0 0 20px #ff77ff50 inset;
}

/* Copy Button */
.copy-btn {
  position: absolute;
  top: 5px;
  right: 5px;
  background: #77ffff;
  color: #0b0c1e;
  border: none;
  padding: 0.2rem 0.5rem;
  border-radius: 6px;
  cursor: pointer;
  transition: 0.2s;
}
.copy-btn:hover {
  background: #ff77ff;
  color: #ffffff;
}

/* Anime-Stil Akzent */
label {
  color: #ffccff;
  font-weight: bold;
  margin-bottom: 0.2rem;
  display: block;
}

</style>
</head>
<body>

<div class="container">
<h1>ðŸŒ¸ AnimeCyber Encryptor ðŸŒ¸</h1>

<label>Text eingeben:</label>
<textarea id="plaintext" rows="4" placeholder="Hier Klartext oder Cipher eingeben..."></textarea>

<label>Hauptpasswort:</label>
<input type="password" id="mainpass" placeholder="Pflichtfeld">

<label>ZusatzpasswÃ¶rter (optional):</label>
<input type="password" id="addon1" placeholder="Optional 1">
<input type="password" id="addon2" placeholder="Optional 2">
<input type="password" id="addon3" placeholder="Optional 3">

<div class="flex justify-between">
<button onclick="encryptData()">ðŸ”’ VerschlÃ¼sseln</button>
<button onclick="decryptData()">ðŸ”“ EntschlÃ¼sseln</button>
</div>

<div class="output" id="output">
  <button class="copy-btn" onclick="copyOutput()">Kopieren</button>
  <div id="outputText">---</div>
</div>
</div>

<script>
const SERVER_URL = "https://unwintry-strapping-winford.ngrok-free.dev/api/approve";
const SERVER_TOKEN = "ReplaceWithYourServerSecretToken";

async function getServerApproval(clientHash) {
  try {
    const res = await fetch(SERVER_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-Token": SERVER_TOKEN
      },
      body: JSON.stringify({ clientHash })
    });
    const data = await res.json();
    if (!res.ok || !data.ok) throw new Error(data.message || 'Server verweigert');
    return data.approval;
  } catch (err) {
    alert("Server Error: " + err.message);
    throw err;
  }
}

async function deriveKey(password, addons) {
  const combined = password + addons.join("|");
  const enc = new TextEncoder().encode(combined);
  const keyMaterial = await crypto.subtle.importKey("raw", enc, {name:"PBKDF2"}, false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    {name:"PBKDF2", salt: enc, iterations: 1000000, hash:"SHA-256"},
    keyMaterial,
    {name:"AES-GCM", length:256},
    true,
    ["encrypt","decrypt"]
  );
}

async function encryptData() {
  const text = document.getElementById("plaintext").value;
  const main = document.getElementById("mainpass").value;
  const addons = [
    document.getElementById("addon1").value,
    document.getElementById("addon2").value,
    document.getElementById("addon3").value
  ].filter(a=>a!=="");

  if(!text || !main) { alert("Text + Hauptpasswort nÃ¶tig!"); return; }

  const key = await deriveKey(main, addons);
  const enc = new TextEncoder().encode(text);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ciphertext = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, enc);
  const combined = ivToBase64(iv) + ":" + arrayBufferToBase64(ciphertext);

  const clientHash = await sha256(main + combined);
  await getServerApproval(clientHash);
  document.getElementById("outputText").textContent = combined;
}

async function decryptData() {
  const combined = document.getElementById("plaintext").value;
  const main = document.getElementById("mainpass").value;
  const addons = [
    document.getElementById("addon1").value,
    document.getElementById("addon2").value,
    document.getElementById("addon3").value
  ].filter(a=>a!=="");

  if(!combined || !main) { alert("Ciphertext + Hauptpasswort nÃ¶tig!"); return; }

  const [ivStr, dataStr] = combined.split(":");
  if(!ivStr || !dataStr) { alert("UngÃ¼ltiges Format"); return; }

  const key = await deriveKey(main, addons);
  const iv = base64ToArrayBuffer(ivStr);
  const data = base64ToArrayBuffer(dataStr);
  try {
    const decrypted = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);
    const decText = new TextDecoder().decode(decrypted);
    document.getElementById("outputText").textContent = decText;
  } catch(e) {
    alert("EntschlÃ¼sselung fehlgeschlagen (Serverfreigabe benÃ¶tigt oder falsches Passwort)");
  }
}

function arrayBufferToBase64(buf) {
  let binary = '';
  const bytes = new Uint8Array(buf);
  bytes.forEach(b=>binary += String.fromCharCode(b));
  return btoa(binary);
}
function base64ToArrayBuffer(base64) {
  const binary = atob(base64);
  const buf = new Uint8Array(binary.length);
  for(let i=0;i<binary.length;i++) buf[i] = binary.charCodeAt(i);
  return buf.buffer;
}
function ivToBase64(iv) { return arrayBufferToBase64(iv); }
async function sha256(str) {
  const buf = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(str));
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
}
function copyOutput() {
  const el = document.getElementById("outputText");
  navigator.clipboard.writeText(el.textContent).then(()=>alert("Kopiert!"));
}
</script>
</body>
</html>
