<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ShadowFX">
    <title>ShadowFX | Secure Session</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap');
        :root { --primary: #ef4444; --bg: #000000; }
        body { 
            background-color: var(--bg); color: #e4e4e7; font-family: 'Inter', sans-serif; 
            height: 100dvh; margin: 0; overflow: hidden; -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        .ios-blur { background: rgba(10, 10, 10, 0.85); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); }
        .full-page-view { position: fixed; inset: 0; background: black; z-index: 10000; transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        .full-page-view.active { transform: translateX(0); visibility: visible; }
        .bubble { max-width: 85%; padding: 12px 16px; border-radius: 12px; font-size: 14px; margin-bottom: 4px; line-height: 1.4; }
        .bubble-in { background: #1c1c1e; color: #fff; align-self: flex-start; border-bottom-left-radius: 2px; }
        .bubble-out { background: #ef4444; color: #fff; align-self: flex-end; border-bottom-right-radius: 2px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .status-online { background: #ef4444; box-shadow: 0 0 10px rgba(239, 68, 68, 0.5); }
        input, textarea { font-size: 16px !important; appearance: none; -webkit-appearance: none; }
        ::-webkit-scrollbar { display: none; }
        * { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>

    <div id="banner" class="fixed top-0 left-0 right-0 z-[50000] p-4 text-center text-[11px] font-bold uppercase hidden shadow-2xl ios-blur text-white border-b border-white/10"></div>

    <!-- Onboarding -->
    <div id="onboarding" class="fixed inset-0 bg-black z-[6000] flex flex-col items-center overflow-y-auto px-8 py-16">
        <div class="mb-10 text-center">
            <div class="relative inline-block">
                <i data-lucide="shield" class="w-16 h-16 text-red-500 mb-4 mx-auto"></i>
                <div class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full animate-pulse"></div>
            </div>
            <h1 class="text-3xl font-bold uppercase text-white tracking-tighter italic">ShadowFX</h1>
            <p class="text-zinc-500 text-[10px] uppercase tracking-[0.3em] font-medium">Encrypted Protocol v2.6</p>
        </div>

        <div class="w-full max-w-md space-y-5">
            <div class="space-y-1">
                <label class="text-[10px] text-zinc-500 ml-2 font-bold uppercase">Operator ID</label>
                <input type="text" id="init-name" placeholder="CODENAME" class="w-full bg-zinc-900/50 p-4 rounded-2xl border border-zinc-800 text-white font-bold outline-none text-sm uppercase focus:border-red-500 transition-all">
            </div>
            <div class="space-y-1">
                <label class="text-[10px] text-zinc-500 ml-2 font-bold uppercase">Master Key</label>
                <input type="password" id="init-psw" placeholder="********" class="w-full bg-zinc-900/50 p-4 rounded-2xl border border-zinc-800 text-white font-bold outline-none text-sm uppercase focus:border-red-500 transition-all">
            </div>
            
            <div class="flex items-center gap-3 p-2 bg-zinc-900/30 rounded-xl">
                <input type="checkbox" id="tos-check" class="w-5 h-5 rounded-md bg-zinc-800 border-zinc-700 checked:bg-red-500">
                <label for="tos-check" class="text-[10px] text-zinc-500 leading-tight uppercase">Verschlüsselung aktivieren & Sicherheitsregeln akzeptieren.</label>
            </div>

            <button onclick="setupVault()" class="w-full bg-red-500 p-5 rounded-2xl font-black text-white uppercase text-sm tracking-widest active:scale-[0.98] transition-all shadow-lg shadow-red-500/20 italic">Initialisieren</button>
        </div>
    </div>

    <!-- Main UI -->
    <div id="app-ui" class="flex flex-col h-full hidden">
        <header class="ios-blur pt-14 pb-5 px-6 border-b border-white/5 flex justify-between items-center z-50">
            <div class="flex flex-col">
                <h1 id="view-title" class="font-black text-2xl tracking-tighter text-white uppercase italic">Tunnel</h1>
                <p id="profile-info" class="text-[9px] text-zinc-500 font-mono tracking-widest uppercase"></p>
            </div>
            <div id="connection-indicator" class="status-dot bg-zinc-800"></div>
        </header>
        
        <main id="main-content" class="flex-1 overflow-y-auto p-5 flex flex-col gap-3"></main>
        
        <nav class="ios-blur pb-10 pt-3 px-12 border-t border-white/5 flex justify-around items-center z-50">
            <button onclick="nav('chats')" id="nav-btn-chats" class="p-3 text-zinc-500 transition-all"><i data-lucide="message-square"></i></button>
            <button onclick="nav('security')" id="nav-btn-security" class="p-3 text-zinc-500 transition-all"><i data-lucide="key-round"></i></button>
        </nav>
    </div>

    <!-- Chat Overlay -->
    <div id="chat-view" class="full-page-view flex flex-col bg-black">
        <header class="ios-blur pt-14 pb-5 px-6 border-b border-white/5 flex items-center gap-5 z-50">
            <button onclick="closeChat()" class="text-zinc-400 active:scale-90 transition-transform"><i data-lucide="chevron-left" class="w-7 h-7"></i></button>
            <div class="flex flex-col flex-1 truncate">
                <h2 id="chat-title" class="font-bold text-white text-lg truncate uppercase tracking-tight italic">...</h2>
                <span class="text-[9px] text-red-500 font-bold tracking-widest uppercase">End-to-End Verschlüsselt</span>
            </div>
        </header>
        <div id="chat-messages" class="flex-1 overflow-y-auto p-6 flex flex-col gap-3"></div>
        <div class="p-4 pb-12 bg-zinc-950 border-t border-white/5 flex gap-3 items-center">
            <input type="text" id="chat-input" placeholder="Sichere Nachricht..." class="flex-1 bg-zinc-900 border border-zinc-800 rounded-2xl px-5 py-4 text-white text-[15px] outline-none focus:border-red-500/50 transition-all">
            <button onclick="sendMessage()" class="w-14 h-14 bg-red-500 rounded-2xl flex items-center justify-center text-white active:scale-90 transition-all shadow-lg shadow-red-500/30"><i data-lucide="send" class="w-6 h-6"></i></button>
        </div>
    </div>

    <!-- Invite Modal -->
    <div id="redeem-modal" class="fixed inset-0 z-[20000] bg-black/98 p-8 flex flex-col justify-center hidden backdrop-blur-xl">
        <div class="text-center mb-8">
            <i data-lucide="user-plus" class="w-12 h-12 text-red-500 mx-auto mb-4"></i>
            <h2 class="text-2xl font-black italic uppercase text-white tracking-tighter">Kontakt Hinzufügen</h2>
            <p class="text-zinc-500 text-[10px] uppercase font-bold mt-1">Geben Sie den SFX-Invite-Code ein</p>
        </div>
        <textarea id="invite-input" placeholder="SFX#..." class="w-full h-40 bg-zinc-900 border border-zinc-800 p-5 rounded-2xl font-mono text-white text-[12px] mb-6 outline-none focus:border-red-500/50 resize-none transition-all"></textarea>
        <button onclick="processInvite()" class="w-full bg-red-500 text-white p-5 rounded-2xl font-black uppercase text-sm tracking-widest active:scale-95 transition-all italic">Anfrage Senden</button>
        <button onclick="$('redeem-modal').classList.add('hidden')" class="mt-6 text-zinc-500 text-xs font-bold uppercase text-center tracking-widest">Abbrechen</button>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        const RELAY_HOST = "shadowfx-chat.de";
        
        let state = {
            profile: null, 
            view: 'chats',
            currentChatId: null,
            socket: null,
            isConnected: false
        };

        // --- Robuste UTF-8 Safe Base64 Helper ---
        function b64Encode(str) {
            const bytes = new TextEncoder().encode(str);
            let binString = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                binString += String.fromCharCode(bytes[i]);
            }
            // Standard Base64 ohne URL-safe Ersetzungen für bessere Kompatibilität mit atob
            return btoa(binString);
        }

        function b64Decode(str) {
            try {
                // Bereinigung: SFX# Präfix entfernen, Leerzeichen, Newlines und escaped Slashes (\/) entfernen
                let cleanStr = str.trim();
                if (cleanStr.startsWith("SFX#")) {
                    cleanStr = cleanStr.substring(4);
                }
                
                // Entferne alle Zeichen, die nicht zum Base64 Alphabet gehören (+ / = A-Z a-z 0-9)
                // Aber behalte - und _ für den Fall, dass sie noch drin sind (URL-safe Fallback)
                cleanStr = cleanStr.replace(/\\/g, ''); // Entferne Backslashes
                cleanStr = cleanStr.replace(/\s/g, ''); // Entferne Whitespace
                
                // Rückumwandlung von URL-safe zu Standard Base64 (falls nötig)
                cleanStr = cleanStr.replace(/-/g, '+').replace(/_/g, '/');
                
                // Fehlendes Padding hinzufügen
                while (cleanStr.length % 4 !== 0) {
                    cleanStr += '=';
                }

                const binString = atob(cleanStr);
                const bytes = new Uint8Array(binString.length);
                for (let i = 0; i < binString.length; i++) {
                    bytes[i] = binString.charCodeAt(i);
                }
                return new TextDecoder().decode(bytes);
            } catch (e) {
                console.error("Base64 Decode Error:", e);
                throw e;
            }
        }

        function copyToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.opacity = "0";
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showBanner("Code kopiert");
            } catch (err) {
                showBanner("Fehler beim Kopieren");
            }
            document.body.removeChild(textArea);
        }

        // --- Crypto Engine ---
        async function exportKeyB64(key, type) {
            const exported = await crypto.subtle.exportKey(type, key);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }

        async function importPubKey(b64) {
            const binary = atob(b64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            return await crypto.subtle.importKey("spki", bytes, { name: "RSA-OAEP", hash: "SHA-256" }, false, ["encrypt"]);
        }

        async function importPrivKey(b64) {
            const binary = atob(b64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            return await crypto.subtle.importKey("pkcs8", bytes, { name: "RSA-OAEP", hash: "SHA-256" }, false, ["decrypt"]);
        }

        async function encryptRSA(data, pubKeyB64) {
            const key = await importPubKey(pubKeyB64);
            const enc = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, key, new TextEncoder().encode(data));
            return btoa(String.fromCharCode(...new Uint8Array(enc)));
        }

        async function decryptRSA(encB64, privKeyB64) {
            const key = await importPrivKey(privKeyB64);
            const binary = atob(encB64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            const dec = await crypto.subtle.decrypt({ name: "RSA-OAEP" }, key, bytes);
            return new TextDecoder().decode(dec);
        }

        async function encryptAES(data, keyB64) {
            const keyBuf = Uint8Array.from(atob(keyB64), c => c.charCodeAt(0));
            const key = await crypto.subtle.importKey("raw", keyBuf, "AES-GCM", false, ["encrypt"]);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const enc = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, new TextEncoder().encode(data));
            const combined = new Uint8Array(iv.length + enc.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(enc), iv.length);
            return btoa(String.fromCharCode(...combined));
        }

        async function decryptAES(encB64, keyB64) {
            const keyBuf = Uint8Array.from(atob(keyB64), c => c.charCodeAt(0));
            const key = await crypto.subtle.importKey("raw", keyBuf, "AES-GCM", false, ["decrypt"]);
            const combined = Uint8Array.from(atob(encB64), c => c.charCodeAt(0));
            const iv = combined.slice(0, 12);
            const data = combined.slice(12);
            const dec = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data);
            return new TextDecoder().decode(dec);
        }

        // --- Core Logic ---
        async function setupVault() {
            const name = $('init-name').value.trim();
            const psw = $('init-psw').value;
            if(!name || !psw || !$('tos-check').checked) return showBanner("Daten unvollständig");

            showBanner("Generiere RSA Vault...");
            const keys = await crypto.subtle.generateKey(
                { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
                true, ["encrypt", "decrypt"]
            );

            state.profile = {
                name: name,
                queueId: "Q-" + Math.random().toString(36).substring(2, 8).toUpperCase(),
                pubKey: await exportKeyB64(keys.publicKey, "spki"),
                privKey: await exportKeyB64(keys.privateKey, "pkcs8"),
                contacts: [],
                requests: [],
                tickets: [],
                history: {}
            };

            saveToStorage();
            bootstrap();
        }

        function saveToStorage() {
            localStorage.setItem('sfx_vault', JSON.stringify(state.profile));
        }

        function initSocket() {
            if(state.socket) state.socket.close();
            state.socket = new WebSocket(`wss://${RELAY_HOST}`);
            
            state.socket.onopen = () => {
                state.socket.send(JSON.stringify({ type: 'OPEN_ANON_QUEUE', queueId: state.profile.queueId }));
            };

            state.socket.onmessage = async (e) => {
                const data = JSON.parse(e.data);
                if(data.type === 'QUEUE_CONFIRMED') {
                    state.isConnected = true;
                    $('connection-indicator').className = 'status-dot status-online';
                    showBanner("System Online");
                }
                if(data.type === 'RELAY_IN') handleIncoming(data.payload);
            };

            state.socket.onclose = () => {
                state.isConnected = false;
                $('connection-indicator').className = 'status-dot bg-zinc-800';
                setTimeout(initSocket, 5000);
            };
        }

        async function handleIncoming(payload) {
            const from = payload.from;
            const contact = state.profile.contacts.find(c => c.pubKey === from);

            try {
                if(!contact) {
                    const dec = await decryptRSA(payload.text, state.profile.privKey);
                    const m = JSON.parse(dec);
                    
                    if(m.t === 'REQ') {
                        if(state.profile.tickets.includes(m.ticket)) {
                            if(!state.profile.requests.find(r => r.pubKey === from)) {
                                state.profile.requests.push({ name: m.n, pubKey: from, queueId: m.q, ticket: m.ticket });
                                saveToStorage(); render();
                                showBanner("Neue Anfrage: " + m.n);
                            }
                        }
                    } else if(m.t === 'ACC') {
                        if(!state.profile.contacts.find(c => c.pubKey === from)) {
                            state.profile.contacts.push({ name: m.n, pubKey: from, queueId: m.q, chatKey: m.ck });
                            state.profile.history[from] = [];
                            saveToStorage(); render();
                            showBanner("Verbindung hergestellt");
                        }
                    }
                } else {
                    const dec = await decryptAES(payload.text, contact.chatKey);
                    const m = JSON.parse(dec);
                    if(!state.profile.history[from]) state.profile.history[from] = [];
                    state.profile.history[from].push({ from: 'them', text: m.x, t: m.t, time: Date.now() });
                    saveToStorage();
                    if(state.currentChatId === from) renderChat();
                    else showBanner("Nachricht von " + contact.name);
                }
            } catch(e) { 
                console.error("Inbound Error", e); 
            }
        }

        async function relayOut(targetQueue, targetPubKey, jsonString, useRSA = true, chatKey = null) {
            if(!state.isConnected) return showBanner("Keine Verbindung");
            let encrypted;
            if(useRSA) {
                encrypted = await encryptRSA(jsonString, targetPubKey);
            } else {
                encrypted = await encryptAES(jsonString, chatKey);
            }

            state.socket.send(JSON.stringify({
                type: 'RELAY_OUT',
                targetQueue: targetQueue,
                payload: { from: state.profile.pubKey, text: encrypted }
            }));
        }

        async function processInvite() {
            const raw = $('invite-input').value.trim();
            if(!raw) return;
            
            try {
                const decodedStr = b64Decode(raw);
                const inv = JSON.parse(decodedStr); 
                
                if(!inv.q || !inv.k || !inv.t) throw new Error("Missing Fields");

                const reqJson = JSON.stringify({
                    t: 'REQ',
                    n: state.profile.name,
                    q: state.profile.queueId,
                    ticket: inv.t
                });

                await relayOut(inv.q, inv.k, reqJson);
                showBanner("Anfrage gesendet...");
                $('redeem-modal').classList.add('hidden');
                $('invite-input').value = "";
            } catch(e) { 
                console.error("Invite Error", e);
                showBanner("Code ungültig"); 
            }
        }

        async function acceptRequest(index) {
            const r = state.profile.requests.splice(index, 1)[0];
            const chatKey = btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(32))));
            
            const accJson = JSON.stringify({
                t: 'ACC',
                n: state.profile.name,
                q: state.profile.queueId,
                ck: chatKey
            });

            await relayOut(r.queueId, r.pubKey, accJson);
            state.profile.contacts.push({ name: r.name, pubKey: r.pubKey, queueId: r.queueId, chatKey: chatKey });
            state.profile.history[r.pubKey] = [];
            state.profile.tickets = state.profile.tickets.filter(t => t !== r.ticket);
            saveToStorage(); render();
        }

        async function sendMessage() {
            const input = $('chat-input');
            const txt = input.value.trim();
            if(!txt || !state.isConnected) return;

            const contact = state.profile.contacts.find(c => c.pubKey === state.currentChatId);
            const msgJson = JSON.stringify({ t: 'MSG', x: txt });

            await relayOut(contact.queueId, contact.pubKey, msgJson, false, contact.chatKey);
            if(!state.profile.history[state.currentChatId]) state.profile.history[state.currentChatId] = [];
            state.profile.history[state.currentChatId].push({ from: 'me', text: txt, time: Date.now() });
            saveToStorage();
            renderChat();
            input.value = "";
        }

        function createTicket() {
            const tId = Math.random().toString(36).substring(2, 10).toUpperCase();
            state.profile.tickets.push(tId);
            saveToStorage(); render();
            showBanner("Key generiert");
        }

        function copyTicket(tId) {
            const json = JSON.stringify({ n: state.profile.name, k: state.profile.pubKey, q: state.profile.queueId, t: tId });
            const code = "SFX#" + b64Encode(json);
            copyToClipboard(code);
        }

        function render() {
            const main = $('main-content');
            main.innerHTML = "";
            $('view-title').innerText = state.view === 'chats' ? "Tunnel" : "Sicherheit";
            $('profile-info').innerText = `NODE: ${state.profile.queueId}`;

            if(state.view === 'chats') {
                main.innerHTML = `<button onclick="$('redeem-modal').classList.remove('hidden')" class="w-full bg-zinc-900/50 border border-white/5 p-5 rounded-2xl text-red-500 text-xs font-black uppercase tracking-widest mb-6 active:scale-[0.98] transition-all flex items-center justify-center gap-2 italic"><i data-lucide="plus-circle" class="w-4 h-4"></i> Invite Einlösen</button>`;
                
                if(state.profile.requests.length > 0) {
                    main.innerHTML += `<div class="text-[10px] text-zinc-500 font-bold uppercase tracking-widest mb-2 px-1">Anfragen</div>`;
                    state.profile.requests.forEach((r, i) => {
                        main.innerHTML += `<div class="bg-zinc-900/80 p-5 rounded-2xl border border-red-500/20 flex justify-between items-center mb-3 animate-pulse">
                            <div><div class="text-white text-sm font-bold uppercase tracking-tight italic">${r.name}</div><div class="text-[9px] text-zinc-500 font-mono">${r.queueId}</div></div>
                            <div class="flex gap-2">
                                <button onclick="state.profile.requests.splice(${i},1);saveToStorage();render();" class="w-12 h-12 bg-zinc-800 rounded-2xl flex items-center justify-center text-zinc-400"><i data-lucide="x" class="w-5 h-5"></i></button>
                                <button onclick="acceptRequest(${i})" class="w-12 h-12 bg-red-500 rounded-2xl flex items-center justify-center text-white"><i data-lucide="check" class="w-5 h-5"></i></button>
                            </div>
                        </div>`;
                    });
                }

                if(state.profile.contacts.length > 0) {
                    main.innerHTML += `<div class="text-[10px] text-zinc-500 font-bold uppercase tracking-widest mb-2 px-1">Tunnel</div>`;
                    state.profile.contacts.forEach(c => {
                        main.innerHTML += `<div onclick="openChat('${c.pubKey}')" class="bg-zinc-900 p-6 rounded-2xl border border-white/5 active:bg-zinc-800 flex items-center gap-5 mb-3 transition-colors">
                            <div class="w-3 h-3 rounded-full bg-red-500 shadow-lg shadow-red-500/50"></div>
                            <div class="text-white text-sm font-black uppercase tracking-tight italic">${c.name}</div>
                        </div>`;
                    });
                } else if(state.profile.requests.length === 0) {
                    main.innerHTML += `<div class="flex-1 flex flex-col items-center justify-center py-20 opacity-20">
                        <i data-lucide="ghost" class="w-16 h-16 mb-4"></i>
                        <p class="text-[10px] font-bold uppercase tracking-widest">Keine Verbindungen</p>
                    </div>`;
                }
            } else {
                main.innerHTML = `<button onclick="createTicket()" class="w-full bg-red-500 p-5 rounded-2xl text-white text-xs font-black uppercase tracking-widest mb-8 active:scale-95 transition-all italic">Key Generieren</button>`;
                if(state.profile.tickets.length > 0) {
                    state.profile.tickets.forEach((t, i) => {
                        main.innerHTML += `<div class="bg-zinc-900 p-5 rounded-2xl border border-white/5 flex justify-between items-center mb-3">
                            <div class="text-zinc-400 font-mono text-[13px] tracking-widest uppercase">${t}</div>
                            <div class="flex gap-2">
                                <button onclick="copyTicket('${t}')" class="w-10 h-10 bg-zinc-800 rounded-xl flex items-center justify-center text-zinc-400"><i data-lucide="copy" class="w-4 h-4"></i></button>
                                <button onclick="state.profile.tickets.splice(state.profile.tickets.indexOf('${t}'),1);saveToStorage();render();" class="w-10 h-10 bg-zinc-800 rounded-xl flex items-center justify-center text-red-900"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </div>
                        </div>`;
                    });
                }
            }
            updateNavIcons();
            lucide.createIcons();
        }

        function updateNavIcons() {
            $('nav-btn-chats').className = `p-3 transition-all ${state.view === 'chats' ? 'text-red-500 scale-110' : 'text-zinc-500'}`;
            $('nav-btn-security').className = `p-3 transition-all ${state.view === 'security' ? 'text-red-500 scale-110' : 'text-zinc-500'}`;
        }

        function openChat(pk) { 
            state.currentChatId = pk; 
            const c = state.profile.contacts.find(c => c.pubKey === pk);
            $('chat-title').innerText = c.name;
            $('chat-view').classList.add('active'); 
            renderChat(); 
        }

        function closeChat() { $('chat-view').classList.remove('active'); state.currentChatId = null; }

        function renderChat() {
            const container = $('chat-messages');
            container.innerHTML = "";
            const history = state.profile.history[state.currentChatId] || [];
            history.forEach(m => {
                const b = document.createElement('div');
                b.className = `bubble ${m.from === 'me' ? 'bubble-out' : 'bubble-in'}`;
                b.innerText = m.text;
                container.appendChild(b);
            });
            container.scrollTop = container.scrollHeight;
        }

        function nav(v) { state.view = v; render(); }
        function bootstrap() { 
            $('onboarding').classList.add('hidden'); 
            $('app-ui').classList.remove('hidden'); 
            initSocket(); render(); 
        }
        function showBanner(t) { 
            const b = $('banner'); b.innerText = t; b.classList.remove('hidden'); 
            setTimeout(() => b.classList.add('hidden'), 3500); 
        }

        window.addEventListener('keydown', (e) => {
            if(e.key === 'Enter') {
                if(!$('onboarding').classList.contains('hidden')) setupVault();
                else if(state.currentChatId) sendMessage();
                else if(!$('redeem-modal').classList.contains('hidden')) processInvite();
            }
        });

        window.onload = () => {
            const saved = localStorage.getItem('sfx_vault');
            if(saved) {
                state.profile = JSON.parse(saved);
                if(!state.profile.history) state.profile.history = {};
                if(!state.profile.tickets) state.profile.tickets = [];
                if(!state.profile.requests) state.profile.requests = [];
                bootstrap();
            }
            lucide.createIcons();
        };
    </script>
</body>
</html>
