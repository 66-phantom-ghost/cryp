<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cyber-Anime Verschl√ºsselungs-Portal</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/argon2-browser/dist/argon2.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;700&display=swap');

body {
    font-family: 'Fira Code', monospace;
    background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    color: #00ffcc;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.card {
    background-color: rgba(0,0,0,0.85);
    border: 2px solid #ff0055;
    border-radius: 1rem;
    padding: 2rem;
    width: 100%;
    max-width: 600px;
    box-shadow: 0 0 20px #ff0055aa;
    animation: fadeIn 1s ease;
}

input, textarea {
    background-color: #111;
    border: 1px solid #ff0055;
    border-radius: 0.5rem;
    padding: 0.5rem;
    color: #00ffcc;
    width: 100%;
}

button {
    background-color: #ff0055;
    color: #fff;
    font-weight: bold;
    padding: 0.7rem 1rem;
    border-radius: 0.5rem;
    transition: all 0.3s ease;
}

button:hover {
    background-color: #ff77aa;
    box-shadow: 0 0 10px #ff77aa;
}

.result-box {
    background-color: #111;
    border: 1px dashed #ff0055;
    padding: 1rem;
    margin-top: 1rem;
    word-break: break-word;
    position: relative;
}

.copy-btn {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    background-color: #00ffaa;
    color: #000;
    font-size: 0.7rem;
    padding: 0.2rem 0.5rem;
    border-radius: 0.3rem;
    cursor: pointer;
}

@keyframes fadeIn {
    0% {opacity:0; transform: translateY(-20px);}
    100% {opacity:1; transform: translateY(0);}
}
</style>
</head>
<body>
<div class="card">
    <h1 class="text-2xl font-bold mb-4 text-center text-pink-400">üå∏ Cyber-Anime Crypto Portal</h1>

    <label>Hauptpasswort:</label>
    <input type="password" id="primaryPassword" placeholder="Pflichtfeld">

    <label class="mt-2">Optionale Zusatzpassw√∂rter (max 3):</label>
    <input type="password" id="extra1" placeholder="Extra 1">
    <input type="password" id="extra2" placeholder="Extra 2">
    <input type="password" id="extra3" placeholder="Extra 3">

    <label class="mt-2">Text zum Verschl√ºsseln/Entschl√ºsseln:</label>
    <textarea id="plainText" rows="4" placeholder="Hier Text eingeben..."></textarea>

    <div class="flex gap-2 mt-4">
        <button onclick="encryptData()">üîí Verschl√ºsseln</button>
        <button onclick="decryptData()">üîì Entschl√ºsseln</button>
    </div>

    <div class="result-box mt-4">
        <div id="output"></div>
        <div class="copy-btn" onclick="copyOutput()">Kopieren</div>
    </div>
</div>

<script>
const SERVER_URL = "https://unwintry-strapping-winford.ngrok-free.dev/api/approve";
const SERVER_TOKEN = "Your_Secret_Token_Here";

async function deriveKey(passwords) {
    // kombiniere Passwort + Zusatzpassw√∂rter
    const combined = passwords.join("|");
    // Argon2id mit moderate St√§rke, 1 Millionen Iterationen f√ºr mindestens eine Komponente
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const key = await argon2.hash({
        pass: combined,
        salt: salt,
        type: argon2.ArgonType.Argon2id,
        time: 2,        // moderate Zeit, schnelle Demo, auf Wunsch auf 1 Million iterationen erh√∂hen
        mem: 64*1024,   // 64 MB
        hashLen: 32
    });
    return hexToArrayBuffer(key.hashHex);
}

async function requestServerApproval(clientHashHex) {
    const res = await fetch(SERVER_URL, {
        method: "POST",
        headers: {"Content-Type":"application/json","X-API-Token":SERVER_TOKEN},
        body: JSON.stringify({clientHash: clientHashHex})
    });
    const data = await res.json();
    if(!data.ok) throw new Error("Serverfreigabe fehlgeschlagen");
    return data.approval;
}

function hexToArrayBuffer(hex) {
    const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte,16)));
    return bytes.buffer;
}

function arrayBufferToBase64(buf) {
    return btoa(String.fromCharCode(...new Uint8Array(buf)));
}

function base64ToArrayBuffer(b64) {
    const binary = atob(b64);
    const bytes = new Uint8Array(binary.length);
    for(let i=0;i<binary.length;i++) bytes[i] = binary.charCodeAt(i);
    return bytes.buffer;
}

async function encryptData() {
    const primary = document.getElementById('primaryPassword').value;
    if(!primary){alert("Hauptpasswort ist Pflicht"); return;}
    const extras = [
        document.getElementById('extra1').value,
        document.getElementById('extra2').value,
        document.getElementById('extra3').value
    ].filter(Boolean);
    const text = document.getElementById('plainText').value;
    if(!text){alert("Text ist leer"); return;}

    // 1Ô∏è‚É£ Key ableiten
    const keyBuffer = await deriveKey([primary,...extras]);

    // 2Ô∏è‚É£ Server-Freigabe
    const clientHashHex = Array.from(new Uint8Array(keyBuffer)).map(b=>b.toString(16).padStart(2,'0')).join('');
    let serverApproval;
    try{
        serverApproval = await requestServerApproval(clientHashHex);
    }catch(e){
        alert(e.message);
        return;
    }

    // 3Ô∏è‚É£ Finaler AES-Key: XOR KeyBuffer + serverApproval
    const approvalBuf = hexToArrayBuffer(serverApproval);
    const finalKeyBytes = new Uint8Array(keyBuffer.byteLength);
    const keyView = new Uint8Array(keyBuffer);
    const approvalView = new Uint8Array(approvalBuf);
    for(let i=0;i<finalKeyBytes.length;i++) finalKeyBytes[i]=keyView[i]^approvalView[i%approvalView.length];

    const cryptoKey = await crypto.subtle.importKey('raw', finalKeyBytes,'AES-GCM',true,['encrypt','decrypt']);

    // 4Ô∏è‚É£ IV
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encBuffer = await crypto.subtle.encrypt({name:'AES-GCM',iv},cryptoKey,new TextEncoder().encode(text));

    const outputStr = ivToStr(iv)+"|"+arrayBufferToBase64(encBuffer);
    document.getElementById('output').textContent = outputStr;
}

async function decryptData() {
    const primary = document.getElementById('primaryPassword').value;
    if(!primary){alert("Hauptpasswort ist Pflicht"); return;}
    const extras = [
        document.getElementById('extra1').value,
        document.getElementById('extra2').value,
        document.getElementById('extra3').value
    ].filter(Boolean);
    const inputText = document.getElementById('plainText').value;
    if(!inputText){alert("Text ist leer"); return;}

    const [ivStr,dataB64] = inputText.split('|');
    const iv = strToIv(ivStr);

    const keyBuffer = await deriveKey([primary,...extras]);
    const clientHashHex = Array.from(new Uint8Array(keyBuffer)).map(b=>b.toString(16).padStart(2,'0')).join('');
    let serverApproval;
    try{
        serverApproval = await requestServerApproval(clientHashHex);
    }catch(e){
        alert(e.message);
        return;
    }

    const approvalBuf = hexToArrayBuffer(serverApproval);
    const finalKeyBytes = new Uint8Array(keyBuffer.byteLength);
    const keyView = new Uint8Array(keyBuffer);
    const approvalView = new Uint8Array(approvalBuf);
    for(let i=0;i<finalKeyBytes.length;i++) finalKeyBytes[i]=keyView[i]^approvalView[i%approvalView.length];

    const cryptoKey = await crypto.subtle.importKey('raw', finalKeyBytes,'AES-GCM',true,['encrypt','decrypt']);

    let plain;
    try{
        const decrypted = await crypto.subtle.decrypt({name:'AES-GCM',iv},cryptoKey,base64ToArrayBuffer(dataB64));
        plain = new TextDecoder().decode(decrypted);
    }catch(e){
        alert("Entschl√ºsselung fehlgeschlagen: falsches Passwort oder Serverfreigabe");
        return;
    }

    document.getElementById('output').textContent = plain;
}

function ivToStr(iv){return Array.from(iv).map(b=>b.toString(16).padStart(2,'0')).join('')}
function strToIv(str){
    const arr = new Uint8Array(str.match(/.{1,2}/g).map(h=>parseInt(h,16)));
    return arr;
}

function copyOutput(){
    const el = document.getElementById('output');
    navigator.clipboard.writeText(el.textContent).then(()=>alert("In die Zwischenablage kopiert"));
}
</script>
</body>
</html>
