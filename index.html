<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Ultra Secure Encryption</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.tailwindcss.com"></script>
<style>
body { font-family: system-ui, sans-serif; }
.glow { box-shadow: 0 0 25px rgba(34,197,94,.35); }
</style>
</head>

<body class="bg-gray-950 text-gray-100 min-h-screen flex items-center justify-center p-6">

<div class="w-full max-w-xl bg-gray-900 p-6 rounded-xl glow">
  <h1 class="text-2xl font-bold text-green-400 mb-4">ğŸ” Serverâ€‘gebundene VerschlÃ¼sselung</h1>

  <textarea id="plain" placeholder="Text eingeben"
    class="w-full p-3 mb-3 bg-gray-800 rounded resize-none h-24"></textarea>

  <input id="pw" type="password" placeholder="Pflichtâ€‘Passwort"
    class="w-full p-3 mb-2 bg-gray-800 rounded">

  <input id="f1" placeholder="Zusatzfaktor 1 (optional)"
    class="w-full p-2 mb-2 bg-gray-800 rounded text-sm">
  <input id="f2" placeholder="Zusatzfaktor 2 (optional)"
    class="w-full p-2 mb-2 bg-gray-800 rounded text-sm">
  <input id="f3" placeholder="Zusatzfaktor 3 (optional)"
    class="w-full p-2 mb-4 bg-gray-800 rounded text-sm">

  <div class="flex gap-2 mb-3">
    <button onclick="encrypt()" class="flex-1 bg-green-600 hover:bg-green-700 p-3 rounded font-semibold">
      VerschlÃ¼sseln
    </button>
    <button onclick="decrypt()" class="flex-1 bg-blue-600 hover:bg-blue-700 p-3 rounded font-semibold">
      EntschlÃ¼sseln
    </button>
  </div>

  <button onclick="copyOut()" class="text-xs bg-gray-700 px-3 py-1 rounded mb-2">
    ğŸ“‹ Ergebnis kopieren
  </button>

  <pre id="out" class="bg-black p-3 rounded text-xs break-all h-40 overflow-auto">
Wartenâ€¦
  </pre>
</div>

<script>
const API_URL = "https://unwintry-strapping-winford.ngrok-free.dev/api/approve";
const ENC = new TextEncoder();
const DEC = new TextDecoder();

/* Utils */
const rand = n => crypto.getRandomValues(new Uint8Array(n));
const b64 = b => btoa(String.fromCharCode(...b));
const ub64 = s => Uint8Array.from(atob(s), c => c.charCodeAt(0));
const sha256 = async b => crypto.subtle.digest("SHA-256", b);

/* Server approval */
async function serverApprove(hashHex) {
  const r = await fetch(API_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ clientHash: hashHex })
  });
  if (!r.ok) throw "Server Fehler";
  const j = await r.json();
  return j.approval;
}

/* Key */
async function deriveKey(material) {
  const base = await crypto.subtle.importKey(
    "raw", ENC.encode(material), "PBKDF2", false, ["deriveKey"]
  );
  return crypto.subtle.deriveKey({
    name: "PBKDF2",
    salt: ENC.encode("srv-bound"),
    iterations: 1_000_000,
    hash: "SHA-256"
  }, base, { name: "AES-GCM", length: 256 }, false, ["encrypt","decrypt"]);
}

/* Encrypt */
async function encrypt() {
  try {
    const pw = pw.value;
    if (!pw) return out.textContent = "âŒ Passwort fehlt";

    const factors = pw + f1.value + f2.value + f3.value;
    const hash = await sha256(ENC.encode(factors));
    const hex = [...new Uint8Array(hash)].map(x=>x.toString(16).padStart(2,"0")).join("");

    const approval = await serverApprove(hex);
    const key = await deriveKey(factors + approval);

    const iv = rand(12);
    const cipher = await crypto.subtle.encrypt(
      { name:"AES-GCM", iv }, key, ENC.encode(plain.value)
    );

    const padL = rand(8 + Math.random()*8|0);
    const padR = rand(8 + Math.random()*8|0);

    const full = new Uint8Array(padL.length + iv.length + cipher.byteLength + padR.length);
    let o=0; full.set(padL,o); o+=padL.length;
    full.set(iv,o); o+=iv.length;
    full.set(new Uint8Array(cipher),o); o+=cipher.byteLength;
    full.set(padR,o);

    out.textContent = "ENCv2:" + b64(full);
  } catch(e) {
    out.textContent = "âŒ Fehler";
  }
}

/* Decrypt */
async function decrypt() {
  try {
    const txt = out.textContent.trim();
    if (!txt.startsWith("ENCv2:")) return;

    const data = ub64(txt.slice(6));
    const iv = data.slice(16, 28);
    const cipher = data.slice(28, data.length-16);

    const factors = pw.value + f1.value + f2.value + f3.value;
    const hash = await sha256(ENC.encode(factors));
    const hex = [...new Uint8Array(hash)].map(x=>x.toString(16).padStart(2,"0")).join("");

    const approval = await serverApprove(hex);
    const key = await deriveKey(factors + approval);

    const plainBuf = await crypto.subtle.decrypt(
      { name:"AES-GCM", iv }, key, cipher
    );
    out.textContent = DEC.decode(plainBuf);
  } catch {
    out.textContent = "âŒ EntschlÃ¼sselung fehlgeschlagen";
  }
}

function copyOut() {
  navigator.clipboard.writeText(out.textContent);
}
</script>
</body>
</html>
